// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_AGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_
#define FLATBUFFERS_GENERATED_AGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace com {
namespace newrelic {
namespace mobile {
namespace fbs {

struct ApplicationLicense;
struct ApplicationLicenseT;

struct ApplicationInfo;
struct ApplicationInfoT;

struct RequestInformation;
struct RequestInformationT;

struct AgentData;
struct AgentDataT;

enum Platform {
  Platform_Android = 0,
  Platform_iOS = 1,
  Platform_tvOS = 2,
  Platform_MIN = Platform_Android,
  Platform_MAX = Platform_tvOS
};

inline Platform (&EnumValuesPlatform())[3] {
  static Platform values[] = {
    Platform_Android,
    Platform_iOS,
    Platform_tvOS
  };
  return values;
}

inline const char **EnumNamesPlatform() {
  static const char *names[] = {
    "Android",
    "iOS",
    "tvOS",
    nullptr
  };
  return names;
}

inline const char *EnumNamePlatform(Platform e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPlatform()[index];
}

struct ApplicationLicenseT : public flatbuffers::NativeTable {
  typedef ApplicationLicense TableType;
  std::string licenseKey;
  uint64_t accountId;
  uint64_t clusterAgentId;
  ApplicationLicenseT()
      : accountId(0),
        clusterAgentId(0) {
  }
};

struct ApplicationLicense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ApplicationLicenseT NativeTableType;
  enum {
    VT_LICENSEKEY = 4,
    VT_ACCOUNTID = 6,
    VT_CLUSTERAGENTID = 8
  };
  const flatbuffers::String *licenseKey() const {
    return GetPointer<const flatbuffers::String *>(VT_LICENSEKEY);
  }
  flatbuffers::String *mutable_licenseKey() {
    return GetPointer<flatbuffers::String *>(VT_LICENSEKEY);
  }
  bool KeyCompareLessThan(const ApplicationLicense *o) const {
    return *licenseKey() < *o->licenseKey();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(licenseKey()->c_str(), val);
  }
  uint64_t accountId() const {
    return GetField<uint64_t>(VT_ACCOUNTID, 0);
  }
  bool mutate_accountId(uint64_t _accountId) {
    return SetField<uint64_t>(VT_ACCOUNTID, _accountId, 0);
  }
  uint64_t clusterAgentId() const {
    return GetField<uint64_t>(VT_CLUSTERAGENTID, 0);
  }
  bool mutate_clusterAgentId(uint64_t _clusterAgentId) {
    return SetField<uint64_t>(VT_CLUSTERAGENTID, _clusterAgentId, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LICENSEKEY) &&
           verifier.Verify(licenseKey()) &&
           VerifyField<uint64_t>(verifier, VT_ACCOUNTID) &&
           VerifyField<uint64_t>(verifier, VT_CLUSTERAGENTID) &&
           verifier.EndTable();
  }
  ApplicationLicenseT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationLicenseT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ApplicationLicense> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationLicenseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_licenseKey(flatbuffers::Offset<flatbuffers::String> licenseKey) {
    fbb_.AddOffset(ApplicationLicense::VT_LICENSEKEY, licenseKey);
  }
  void add_accountId(uint64_t accountId) {
    fbb_.AddElement<uint64_t>(ApplicationLicense::VT_ACCOUNTID, accountId, 0);
  }
  void add_clusterAgentId(uint64_t clusterAgentId) {
    fbb_.AddElement<uint64_t>(ApplicationLicense::VT_CLUSTERAGENTID, clusterAgentId, 0);
  }
  ApplicationLicenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ApplicationLicenseBuilder &operator=(const ApplicationLicenseBuilder &);
  flatbuffers::Offset<ApplicationLicense> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ApplicationLicense>(end);
    fbb_.Required(o, ApplicationLicense::VT_LICENSEKEY);
    return o;
  }
};

inline flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> licenseKey = 0,
    uint64_t accountId = 0,
    uint64_t clusterAgentId = 0) {
  ApplicationLicenseBuilder builder_(_fbb);
  builder_.add_clusterAgentId(clusterAgentId);
  builder_.add_accountId(accountId);
  builder_.add_licenseKey(licenseKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<ApplicationLicense> CreateApplicationLicenseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *licenseKey = nullptr,
    uint64_t accountId = 0,
    uint64_t clusterAgentId = 0) {
  return com::newrelic::mobile::fbs::CreateApplicationLicense(
      _fbb,
      licenseKey ? _fbb.CreateString(licenseKey) : 0,
      accountId,
      clusterAgentId);
}

flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplicationInfoT : public flatbuffers::NativeTable {
  typedef ApplicationInfo TableType;
  std::unique_ptr<ApplicationLicenseT> applicationLicense;
  Platform platform;
  std::string appVersion;
  uint64_t appVersionId;
  ApplicationInfoT()
      : platform(Platform_Android),
        appVersionId(0) {
  }
};

struct ApplicationInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ApplicationInfoT NativeTableType;
  enum {
    VT_APPLICATIONLICENSE = 4,
    VT_PLATFORM = 6,
    VT_APPVERSION = 8,
    VT_APPVERSIONID = 10
  };
  const ApplicationLicense *applicationLicense() const {
    return GetPointer<const ApplicationLicense *>(VT_APPLICATIONLICENSE);
  }
  ApplicationLicense *mutable_applicationLicense() {
    return GetPointer<ApplicationLicense *>(VT_APPLICATIONLICENSE);
  }
  Platform platform() const {
    return static_cast<Platform>(GetField<uint8_t>(VT_PLATFORM, 0));
  }
  bool mutate_platform(Platform _platform) {
    return SetField<uint8_t>(VT_PLATFORM, static_cast<uint8_t>(_platform), 0);
  }
  const flatbuffers::String *appVersion() const {
    return GetPointer<const flatbuffers::String *>(VT_APPVERSION);
  }
  flatbuffers::String *mutable_appVersion() {
    return GetPointer<flatbuffers::String *>(VT_APPVERSION);
  }
  uint64_t appVersionId() const {
    return GetField<uint64_t>(VT_APPVERSIONID, 0);
  }
  bool mutate_appVersionId(uint64_t _appVersionId) {
    return SetField<uint64_t>(VT_APPVERSIONID, _appVersionId, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_APPLICATIONLICENSE) &&
           verifier.VerifyTable(applicationLicense()) &&
           VerifyField<uint8_t>(verifier, VT_PLATFORM) &&
           VerifyOffset(verifier, VT_APPVERSION) &&
           verifier.Verify(appVersion()) &&
           VerifyField<uint64_t>(verifier, VT_APPVERSIONID) &&
           verifier.EndTable();
  }
  ApplicationInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ApplicationInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_applicationLicense(flatbuffers::Offset<ApplicationLicense> applicationLicense) {
    fbb_.AddOffset(ApplicationInfo::VT_APPLICATIONLICENSE, applicationLicense);
  }
  void add_platform(Platform platform) {
    fbb_.AddElement<uint8_t>(ApplicationInfo::VT_PLATFORM, static_cast<uint8_t>(platform), 0);
  }
  void add_appVersion(flatbuffers::Offset<flatbuffers::String> appVersion) {
    fbb_.AddOffset(ApplicationInfo::VT_APPVERSION, appVersion);
  }
  void add_appVersionId(uint64_t appVersionId) {
    fbb_.AddElement<uint64_t>(ApplicationInfo::VT_APPVERSIONID, appVersionId, 0);
  }
  ApplicationInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ApplicationInfoBuilder &operator=(const ApplicationInfoBuilder &);
  flatbuffers::Offset<ApplicationInfo> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<ApplicationInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ApplicationLicense> applicationLicense = 0,
    Platform platform = Platform_Android,
    flatbuffers::Offset<flatbuffers::String> appVersion = 0,
    uint64_t appVersionId = 0) {
  ApplicationInfoBuilder builder_(_fbb);
  builder_.add_appVersionId(appVersionId);
  builder_.add_appVersion(appVersion);
  builder_.add_applicationLicense(applicationLicense);
  builder_.add_platform(platform);
  return builder_.Finish();
}

inline flatbuffers::Offset<ApplicationInfo> CreateApplicationInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ApplicationLicense> applicationLicense = 0,
    Platform platform = Platform_Android,
    const char *appVersion = nullptr,
    uint64_t appVersionId = 0) {
  return com::newrelic::mobile::fbs::CreateApplicationInfo(
      _fbb,
      applicationLicense,
      platform,
      appVersion ? _fbb.CreateString(appVersion) : 0,
      appVersionId);
}

flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RequestInformationT : public flatbuffers::NativeTable {
  typedef RequestInformation TableType;
  uint64_t requestTimestampMs;
  uint32_t requestAddress;
  RequestInformationT()
      : requestTimestampMs(0),
        requestAddress(0) {
  }
};

struct RequestInformation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestInformationT NativeTableType;
  enum {
    VT_REQUESTTIMESTAMPMS = 4,
    VT_REQUESTADDRESS = 6
  };
  uint64_t requestTimestampMs() const {
    return GetField<uint64_t>(VT_REQUESTTIMESTAMPMS, 0);
  }
  bool mutate_requestTimestampMs(uint64_t _requestTimestampMs) {
    return SetField<uint64_t>(VT_REQUESTTIMESTAMPMS, _requestTimestampMs, 0);
  }
  uint32_t requestAddress() const {
    return GetField<uint32_t>(VT_REQUESTADDRESS, 0);
  }
  bool mutate_requestAddress(uint32_t _requestAddress) {
    return SetField<uint32_t>(VT_REQUESTADDRESS, _requestAddress, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_REQUESTTIMESTAMPMS) &&
           VerifyField<uint32_t>(verifier, VT_REQUESTADDRESS) &&
           verifier.EndTable();
  }
  RequestInformationT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RequestInformationT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RequestInformation> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RequestInformationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_requestTimestampMs(uint64_t requestTimestampMs) {
    fbb_.AddElement<uint64_t>(RequestInformation::VT_REQUESTTIMESTAMPMS, requestTimestampMs, 0);
  }
  void add_requestAddress(uint32_t requestAddress) {
    fbb_.AddElement<uint32_t>(RequestInformation::VT_REQUESTADDRESS, requestAddress, 0);
  }
  RequestInformationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestInformationBuilder &operator=(const RequestInformationBuilder &);
  flatbuffers::Offset<RequestInformation> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RequestInformation>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestInformation> CreateRequestInformation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t requestTimestampMs = 0,
    uint32_t requestAddress = 0) {
  RequestInformationBuilder builder_(_fbb);
  builder_.add_requestTimestampMs(requestTimestampMs);
  builder_.add_requestAddress(requestAddress);
  return builder_.Finish();
}

flatbuffers::Offset<RequestInformation> CreateRequestInformation(flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AgentDataT : public flatbuffers::NativeTable {
  typedef AgentData TableType;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::StringSessionAttributeT>> stringAttributes;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::LongSessionAttributeT>> longAttributes;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::DoubleSessionAttributeT>> doubleAttributes;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::BoolSessionAttributeT>> boolAttributes;
  std::vector<std::unique_ptr<com::newrelic::mobile::fbs::hex::HandledExceptionT>> handledExceptions;
  std::unique_ptr<ApplicationInfoT> applicationInfo;
  std::unique_ptr<RequestInformationT> requestInfo;
  AgentDataT() {
  }
};

struct AgentData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AgentDataT NativeTableType;
  enum {
    VT_STRINGATTRIBUTES = 4,
    VT_LONGATTRIBUTES = 6,
    VT_DOUBLEATTRIBUTES = 8,
    VT_BOOLATTRIBUTES = 10,
    VT_HANDLEDEXCEPTIONS = 12,
    VT_APPLICATIONINFO = 14,
    VT_REQUESTINFO = 16
  };
  const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *stringAttributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *>(VT_STRINGATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *mutable_stringAttributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *>(VT_STRINGATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *longAttributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *>(VT_LONGATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *mutable_longAttributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *>(VT_LONGATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *doubleAttributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *>(VT_DOUBLEATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *mutable_doubleAttributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *>(VT_DOUBLEATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *boolAttributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *>(VT_BOOLATTRIBUTES);
  }
  flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *mutable_boolAttributes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *>(VT_BOOLATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *handledExceptions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *>(VT_HANDLEDEXCEPTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *mutable_handledExceptions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *>(VT_HANDLEDEXCEPTIONS);
  }
  const ApplicationInfo *applicationInfo() const {
    return GetPointer<const ApplicationInfo *>(VT_APPLICATIONINFO);
  }
  ApplicationInfo *mutable_applicationInfo() {
    return GetPointer<ApplicationInfo *>(VT_APPLICATIONINFO);
  }
  const RequestInformation *requestInfo() const {
    return GetPointer<const RequestInformation *>(VT_REQUESTINFO);
  }
  RequestInformation *mutable_requestInfo() {
    return GetPointer<RequestInformation *>(VT_REQUESTINFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRINGATTRIBUTES) &&
           verifier.Verify(stringAttributes()) &&
           verifier.VerifyVectorOfTables(stringAttributes()) &&
           VerifyOffset(verifier, VT_LONGATTRIBUTES) &&
           verifier.Verify(longAttributes()) &&
           verifier.VerifyVectorOfTables(longAttributes()) &&
           VerifyOffset(verifier, VT_DOUBLEATTRIBUTES) &&
           verifier.Verify(doubleAttributes()) &&
           verifier.VerifyVectorOfTables(doubleAttributes()) &&
           VerifyOffset(verifier, VT_BOOLATTRIBUTES) &&
           verifier.Verify(boolAttributes()) &&
           verifier.VerifyVectorOfTables(boolAttributes()) &&
           VerifyOffset(verifier, VT_HANDLEDEXCEPTIONS) &&
           verifier.Verify(handledExceptions()) &&
           verifier.VerifyVectorOfTables(handledExceptions()) &&
           VerifyOffset(verifier, VT_APPLICATIONINFO) &&
           verifier.VerifyTable(applicationInfo()) &&
           VerifyOffset(verifier, VT_REQUESTINFO) &&
           verifier.VerifyTable(requestInfo()) &&
           verifier.EndTable();
  }
  AgentDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AgentDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AgentData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AgentDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AgentDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stringAttributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>> stringAttributes) {
    fbb_.AddOffset(AgentData::VT_STRINGATTRIBUTES, stringAttributes);
  }
  void add_longAttributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>> longAttributes) {
    fbb_.AddOffset(AgentData::VT_LONGATTRIBUTES, longAttributes);
  }
  void add_doubleAttributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>> doubleAttributes) {
    fbb_.AddOffset(AgentData::VT_DOUBLEATTRIBUTES, doubleAttributes);
  }
  void add_boolAttributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>> boolAttributes) {
    fbb_.AddOffset(AgentData::VT_BOOLATTRIBUTES, boolAttributes);
  }
  void add_handledExceptions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>> handledExceptions) {
    fbb_.AddOffset(AgentData::VT_HANDLEDEXCEPTIONS, handledExceptions);
  }
  void add_applicationInfo(flatbuffers::Offset<ApplicationInfo> applicationInfo) {
    fbb_.AddOffset(AgentData::VT_APPLICATIONINFO, applicationInfo);
  }
  void add_requestInfo(flatbuffers::Offset<RequestInformation> requestInfo) {
    fbb_.AddOffset(AgentData::VT_REQUESTINFO, requestInfo);
  }
  AgentDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AgentDataBuilder &operator=(const AgentDataBuilder &);
  flatbuffers::Offset<AgentData> Finish() {
    const auto end = fbb_.EndTable(start_, 7);
    auto o = flatbuffers::Offset<AgentData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AgentData> CreateAgentData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>> stringAttributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>> longAttributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>> doubleAttributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>> boolAttributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>> handledExceptions = 0,
    flatbuffers::Offset<ApplicationInfo> applicationInfo = 0,
    flatbuffers::Offset<RequestInformation> requestInfo = 0) {
  AgentDataBuilder builder_(_fbb);
  builder_.add_requestInfo(requestInfo);
  builder_.add_applicationInfo(applicationInfo);
  builder_.add_handledExceptions(handledExceptions);
  builder_.add_boolAttributes(boolAttributes);
  builder_.add_doubleAttributes(doubleAttributes);
  builder_.add_longAttributes(longAttributes);
  builder_.add_stringAttributes(stringAttributes);
  return builder_.Finish();
}

inline flatbuffers::Offset<AgentData> CreateAgentDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>> *stringAttributes = nullptr,
    const std::vector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>> *longAttributes = nullptr,
    const std::vector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>> *doubleAttributes = nullptr,
    const std::vector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>> *boolAttributes = nullptr,
    const std::vector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>> *handledExceptions = nullptr,
    flatbuffers::Offset<ApplicationInfo> applicationInfo = 0,
    flatbuffers::Offset<RequestInformation> requestInfo = 0) {
  return com::newrelic::mobile::fbs::CreateAgentData(
      _fbb,
      stringAttributes ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>(*stringAttributes) : 0,
      longAttributes ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>(*longAttributes) : 0,
      doubleAttributes ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>(*doubleAttributes) : 0,
      boolAttributes ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>(*boolAttributes) : 0,
      handledExceptions ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>(*handledExceptions) : 0,
      applicationInfo,
      requestInfo);
}

flatbuffers::Offset<AgentData> CreateAgentData(flatbuffers::FlatBufferBuilder &_fbb, const AgentDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ApplicationLicenseT *ApplicationLicense::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ApplicationLicenseT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ApplicationLicense::UnPackTo(ApplicationLicenseT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = licenseKey(); if (_e) _o->licenseKey = _e->str(); };
  { auto _e = accountId(); _o->accountId = _e; };
  { auto _e = clusterAgentId(); _o->clusterAgentId = _e; };
}

inline flatbuffers::Offset<ApplicationLicense> ApplicationLicense::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplicationLicense(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ApplicationLicense> CreateApplicationLicense(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationLicenseT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _licenseKey = _fbb.CreateString(_o->licenseKey);
  auto _accountId = _o->accountId;
  auto _clusterAgentId = _o->clusterAgentId;
  return com::newrelic::mobile::fbs::CreateApplicationLicense(
      _fbb,
      _licenseKey,
      _accountId,
      _clusterAgentId);
}

inline ApplicationInfoT *ApplicationInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ApplicationInfoT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ApplicationInfo::UnPackTo(ApplicationInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = applicationLicense(); if (_e) _o->applicationLicense = std::unique_ptr<ApplicationLicenseT>(_e->UnPack(_resolver)); };
  { auto _e = platform(); _o->platform = _e; };
  { auto _e = appVersion(); if (_e) _o->appVersion = _e->str(); };
  { auto _e = appVersionId(); _o->appVersionId = _e; };
}

inline flatbuffers::Offset<ApplicationInfo> ApplicationInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplicationInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ApplicationInfo> CreateApplicationInfo(flatbuffers::FlatBufferBuilder &_fbb, const ApplicationInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _applicationLicense = _o->applicationLicense ? CreateApplicationLicense(_fbb, _o->applicationLicense.get(), _rehasher) : 0;
  auto _platform = _o->platform;
  auto _appVersion = _o->appVersion.size() ? _fbb.CreateString(_o->appVersion) : 0;
  auto _appVersionId = _o->appVersionId;
  return com::newrelic::mobile::fbs::CreateApplicationInfo(
      _fbb,
      _applicationLicense,
      _platform,
      _appVersion,
      _appVersionId);
}

inline RequestInformationT *RequestInformation::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RequestInformationT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RequestInformation::UnPackTo(RequestInformationT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = requestTimestampMs(); _o->requestTimestampMs = _e; };
  { auto _e = requestAddress(); _o->requestAddress = _e; };
}

inline flatbuffers::Offset<RequestInformation> RequestInformation::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRequestInformation(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RequestInformation> CreateRequestInformation(flatbuffers::FlatBufferBuilder &_fbb, const RequestInformationT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _requestTimestampMs = _o->requestTimestampMs;
  auto _requestAddress = _o->requestAddress;
  return com::newrelic::mobile::fbs::CreateRequestInformation(
      _fbb,
      _requestTimestampMs,
      _requestAddress);
}

inline AgentDataT *AgentData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AgentDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AgentData::UnPackTo(AgentDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stringAttributes(); if (_e) { _o->stringAttributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stringAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::StringSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = longAttributes(); if (_e) { _o->longAttributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->longAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::LongSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = doubleAttributes(); if (_e) { _o->doubleAttributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->doubleAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::DoubleSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = boolAttributes(); if (_e) { _o->boolAttributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boolAttributes[_i] = std::unique_ptr<com::newrelic::mobile::fbs::BoolSessionAttributeT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = handledExceptions(); if (_e) { _o->handledExceptions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->handledExceptions[_i] = std::unique_ptr<com::newrelic::mobile::fbs::hex::HandledExceptionT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = applicationInfo(); if (_e) _o->applicationInfo = std::unique_ptr<ApplicationInfoT>(_e->UnPack(_resolver)); };
  { auto _e = requestInfo(); if (_e) _o->requestInfo = std::unique_ptr<RequestInformationT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AgentData> AgentData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AgentDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAgentData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AgentData> CreateAgentData(flatbuffers::FlatBufferBuilder &_fbb, const AgentDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  auto _stringAttributes = _o->stringAttributes.size() ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::StringSessionAttribute>>(_o->stringAttributes.size(), [&](size_t i) { return CreateStringSessionAttribute(_fbb, _o->stringAttributes[i].get(), _rehasher); }) : 0;
  auto _longAttributes = _o->longAttributes.size() ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::LongSessionAttribute>>(_o->longAttributes.size(), [&](size_t i) { return CreateLongSessionAttribute(_fbb, _o->longAttributes[i].get(), _rehasher); }) : 0;
  auto _doubleAttributes = _o->doubleAttributes.size() ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::DoubleSessionAttribute>>(_o->doubleAttributes.size(), [&](size_t i) { return CreateDoubleSessionAttribute(_fbb, _o->doubleAttributes[i].get(), _rehasher); }) : 0;
  auto _boolAttributes = _o->boolAttributes.size() ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::BoolSessionAttribute>>(_o->boolAttributes.size(), [&](size_t i) { return CreateBoolSessionAttribute(_fbb, _o->boolAttributes[i].get(), _rehasher); }) : 0;
  auto _handledExceptions = _o->handledExceptions.size() ? _fbb.CreateVector<flatbuffers::Offset<com::newrelic::mobile::fbs::hex::HandledException>>(_o->handledExceptions.size(), [&](size_t i) { return CreateHandledException(_fbb, _o->handledExceptions[i].get(), _rehasher); }) : 0;
  auto _applicationInfo = _o->applicationInfo ? CreateApplicationInfo(_fbb, _o->applicationInfo.get(), _rehasher) : 0;
  auto _requestInfo = _o->requestInfo ? CreateRequestInformation(_fbb, _o->requestInfo.get(), _rehasher) : 0;
  return com::newrelic::mobile::fbs::CreateAgentData(
      _fbb,
      _stringAttributes,
      _longAttributes,
      _doubleAttributes,
      _boolAttributes,
      _handledExceptions,
      _applicationInfo,
      _requestInfo);
}

inline const com::newrelic::mobile::fbs::AgentData *GetAgentData(const void *buf) {
  return flatbuffers::GetRoot<com::newrelic::mobile::fbs::AgentData>(buf);
}

inline AgentData *GetMutableAgentData(void *buf) {
  return flatbuffers::GetMutableRoot<AgentData>(buf);
}

inline bool VerifyAgentDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<com::newrelic::mobile::fbs::AgentData>(nullptr);
}

inline void FinishAgentDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<com::newrelic::mobile::fbs::AgentData> root) {
  fbb.Finish(root);
}

inline std::unique_ptr<AgentDataT> UnPackAgentData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<AgentDataT>(GetAgentData(buf)->UnPack(res));
}

}  // namespace fbs
}  // namespace mobile
}  // namespace newrelic
}  // namespace com

#endif  // FLATBUFFERS_GENERATED_AGENTDATA_COM_NEWRELIC_MOBILE_FBS_H_
